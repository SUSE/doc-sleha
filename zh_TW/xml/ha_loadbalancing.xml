<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="ha_loadbalancing.xml" version="5.0" xml:id="cha.ha.lb">

 <title>載入平衡</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:maintainer/>
        <dm:status>編輯</dm:status>
        <dm:deadline/>
        <dm:priority/>
        <dm:translation>yes</dm:translation>
        <dm:languages/>
        <dm:release/>
        <dm:repository/>
      </dm:docmanager>
    </info>
    
 <para>
  在<emphasis>負載平衡</emphasis>的情況下，一個伺服器叢集對於外部用戶端而言就是一台大型的高速伺服器。這種表面上的單個伺服器稱為<emphasis>虛擬伺服器</emphasis>。它包含一或多個用於發送內送要求的負載平衡器，以及數個執行實際服務的真實伺服器。對 High Availability Extension 完成負載平衡設定後，您可以建置擴充性強、可用性高的網路服務，例如 Web、快取、郵件、FTP、媒體和 VoIP 服務。
 </para>
 <para>
  High Availability Extension 支援兩種負載平衡技術：Linux 虛擬伺服器 (LVS) 和 HAProxy。兩者的主要差別在於，Linux 虛擬伺服器在 OSI 第 4 層 (傳輸層) 上運作，可設定核心的網路層，而 HAProxy 在第 7 層 (應用程式層) 上的使用者空間中執行。因此，Linux 虛擬伺服器所需的資源更少，但處理的負載更多，而 HAProxy 可以檢查流量，執行 SSL 終止，以及根據流量內容做出分派決策。
 </para>
 <para>另一方面，Linux 虛擬伺服器包含兩個不同的軟體：IPVS (IP 虛擬伺服器) 和 KTCPVS (核心 TCP 虛擬伺服器)。IPVS 提供第 4 層負載平衡，而 KTCPVS 提供第 7 層負載平衡。
 </para>

 <para> 本章會提供負載平衡與高可用性結合使用的概念綜覽，然後簡要介紹 Linux 虛擬伺服器和 HAProxy。最後，提供其他閱讀材料的連結。 </para>
 <sect1 xml:id="sec.ha.lb.overview">
  <title>概念綜覽</title>

  <para>
   實際的伺服器與負載平衡器之間可透過高速 LAN 或地理位置分散的 WAN 來連接。負載平衡器會將要求發送到不同的伺服器。它們可以讓叢集的多個平行服務顯示為單一 IP 位址 (虛擬 IP 位址或 VIP) 上的一個虛擬服務。發送請求可以使用 IP 負載平衡技術或應用程式層級的負載平衡技術。以透明方式在叢集中新增或移除節點可以實現系統的延展性。
  </para>

  <para>
   高可用性透過偵測節點或服務失敗，並相應地照常重新設定整個虛擬伺服器系統來實現。
  </para>

  <remark>Most of the following items are taken from FATE#316459. Not
  sure if this is really correct. Needs technical proofreading by an
  expert.</remark>

  <para>
   負載平衡策略有多種。以下是一些適用於 Linux 虛擬伺服器的第 4 層策略：
  </para>

  <itemizedlist>
   <listitem>
    <formalpara>
     <title>遞迴</title>
     <para>
      最簡單的策略就是將每個連接輪流導向至不同的位址。例如，一個 DNS 伺服器可能有多個項目對應於一個指定主機名稱。使用 DNS 遞迴時，該 DNS 伺服器會輪流傳回所有這些項目。因此，不同的用戶端將會看到不同的位址。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>選取<quote>最佳</quote>伺服器</title>
     <para>
      雖然此策略存在一些弊端，但您可以使用<quote>第一台做出回應的伺服器</quote>或<quote>負載最低的伺服器</quote>方案來實現平衡。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>平衡每台伺服器的連接數</title>
     <para>
      使用者與伺服器之間的負載平衡器可以將一定數量的使用者分散到多台伺服器上。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>地理位置</title>
     <para>
      可以將用戶端導向至附近的伺服器。
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   以下是一些適用於 HAProxy 的第 7 層策略：
  </para>

  <itemizedlist>
   <listitem>
    <formalpara>
     <title>URI</title>
     <para>
      檢查 HTTP 內容並將其發送到最適合此特定 URL 的伺服器。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>URL 參數、RDP Cookie</title>
     <para>
      檢查 HTTP 內容中的工作階段參數 (可能在 post 參數中) 或 RDP (遠端桌面通訊協定) 工作階段 cookie，並將其發送到為此工作階段提供服務的伺服器。
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   儘管與前一種策略存在一些相同之處，但如果 LVS/<command>ipvsadm</command> 無法滿足需要，您可以使用 HAProxy，反之亦然：
  </para>

  <itemizedlist>
   <listitem>
    <formalpara>
     <title>SSL 終止</title>
     <para>
      前端負載平衡器可以處理 SSL 層。因此，雲端節點不需要存取 SSL 金鑰，而可以利用負載平衡器中的 SSL 加速器。
     </para>
    </formalpara>
   </listitem>
   <listitem>
    <formalpara>
     <title>應用程式層級</title>
     <para>
      HAProxy 在應用程式層級運作，因此，負載平衡決策受內容資料流的影響。這樣，便可以根據 cookie 和其他此類過濾器實現持久性。
     </para>
    </formalpara>
   </listitem>
  </itemizedlist>

  <para>
   另一方面，HAProxy 不能完全取代 LVS/<command>ipvsadm</command>：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     LVS 支援<quote>直接路由</quote>，在此模式下，負載平衡器只運作於內傳資料流中，而外傳流量將直接路由至用戶端。在非對稱環境中，這有可能會大幅提高輸送量。
    </para>
   </listitem>
   <listitem>
    <para>
     LVS 支援複製可設定狀態的連接表 (透過 <systemitem class="daemon">conntrackd</systemitem>)。如此便能實現對用戶端和伺服器透明的負載平衡器容錯移轉。
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="sec.ha.lb.lvs">
  <title>使用 Linux 虛擬伺服器設定負載平衡</title>

  <para>
   以下幾節概要介紹了主要的 LVS 元件和概念。然後，將介紹如何在 High Availability Extension 上設定 Linux 虛擬伺服器。
  </para>

  <sect2 xml:id="sec.ha.lvs.overview.director">
   <title>導向器</title>
   <para>
    LVS 的主要元件是 ip_vs (或 IPVS) 核心代碼。它會在 Linux 核心 (第 4 層交換) 內執行輸送層負載平衡。執行包含 IPVS 代碼的 Linux 核心的節點稱為<emphasis>導向器</emphasis>。在導向器上執行的 IPVS 代碼是 LVS 的必要特性。
   </para>
   <para>
    當用戶端連接到導向器時，內送請求會在所有叢集節點上達到負載平衡︰導向器會使用可使 LVS 工作的一組修改後路由規則，將封包轉遞到實際的伺服器。也即是，導向器不會發起或終止連接，也不會傳送確認通知等等。導向器的作用相當於專用路由器，它會將來自終端使用者的封包轉遞到實際的伺服器 (執行負責處理要求之應用程式的主機)。
   </para>
   <para>
    依預設，此核心不需要安裝 IPVS 模組。IPVS 核心模組包含在 <systemitem class="resource">cluster-network-kmp-default</systemitem> 套件內。
   </para>
  </sect2>

  <sect2 xml:id="sec.ha.lvs.overview.userspace">
   <title>使用者空間控制器和精靈</title>
   <para>
    <systemitem class="daemon">ldirectord</systemitem> 是一個使用者空間精靈，可在 LVS 負載平衡虛擬伺服器叢集中管理 Linux Virtual Server 和監控實際的伺服器。組態檔案 <filename>/etc/ha.d/ldirectord.cf</filename> 指定虛擬服務及其關聯的實際伺服器，並告知 <systemitem class="daemon">ldirectord</systemitem> 如何將伺服器設定為 LVS 重新導向器。啟始化精靈時，會為叢集建立虛擬服務。
   </para>
   <para>
    <systemitem class="daemon">ldirectord</systemitem> 精靈透過不時發出已知 URL 請求並檢查回應的方式，監控實際伺服器的狀態。如果實際伺服器出現故障，便會從負載平衡器的可用伺服器清單中移除。當服務監控器偵測到該停止的伺服器已恢復正常並可重新運作時，會重新將該伺服器新增到可用伺服器清單中。可以指定一台錯誤回復伺服器 (讓 Web 服務重新導向到該伺服器)，以防所有實際伺服器都當機。錯誤回復伺服器通常是本地主機，它會顯示一個緊急頁面，告知 Web 服務暫時不可用。
   </para>
   <para>
    <systemitem class="daemon">ldirectord</systemitem> 使用 <systemitem>ipvsadm</systemitem> 工具 (<systemitem class="resource">ipvsadm</systemitem> 套件) 來處理 Linux 核心中的虛擬伺服器表格。
   </para>
  </sect2>

  <sect2 xml:id="sec.ha.lvs.overview.forwarding">
   <title>封包轉遞</title>
   <para>
    導向器將用戶端封包傳送至實際伺服器的方式有三種︰
   </para>
   <variablelist>
    <varlistentry>
     <term>網址轉譯 (NAT)</term>
     <listitem>
      <para>
       內送的要求會送達虛擬的 IP 位址，然後透過將目的地 IP 位址和連接埠變更為所選實際伺服器的 IP 位址和連接埠，將這些要求轉遞至實際伺服器。實際伺服器會將回應傳送至負載平衡器，再由負載平衡器變更目的地 IP 位址，並將回應轉遞回用戶端。因此，終端使用者會從預期的來源收到回覆。由於所有流量都會通過負載平衡器，因此它往往成為叢集的瓶頸。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>IP 通道封裝 (IP-IP 封裝)</term>
     <listitem>
      <para>
       IP 通道封裝能將定址到某 IP 位址的封包重新導向至另一個位址 (可能位於不同的網路)。LVS 透過 IP 通道將請求傳送至實際的伺服器 (重新導向至不同的 IP 位址)，然後實際伺服器使用自己的路由表直接回覆用戶端。叢集成員可以位於不同的子網路。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>直接路由</term>
     <listitem>
      <para>
       直接將終端使用者的封包轉遞到實際的伺服器。IP 封包並未修改，因此必須將實際伺服器設定為接受送往虛擬伺服器 IP 位址的流量。實際伺服器的回應將直接傳送至用戶端。實際伺服器和負載平衡器需位於相同的實體網路節區。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.ha.lvs.overview.schedulers">
   <title>排程演算法</title>
   <para>
    使用哪一部實際伺服器來處理用戶端請求的新連接，是由不同的演算法決定的。這些演算法以模組的形式提供，可根據特定需求進行調整。如需可用模組的綜覽，請參閱 <command>ipvsadm(8)</command> man 頁面。從用戶端接收到連接請求後，導向器會依據<emphasis>排程</emphasis>為該用戶端指定實際的伺服器。排程器是 IPVS 核心代碼的一部分，用於決定哪一部實際伺服器將獲取下一個新連接。
   </para>
    <para>如需 Linux 虛擬伺服器排程演算法的更詳細描述，請造訪 <link xlink:href="http://kb.linuxvirtualserver.org/wiki/IPVS"/>。此外，還可以在 <command>ipvsadm</command> man 頁面中搜尋 <option>--scheduler</option>。
    </para>
    <para>可以在 <link xlink:href="http://www.haproxy.org/download/1.6/doc/configuration.txt"/> 上找到 HAProxy 的相關負載平衡策略。
    </para>
  </sect2>

  <sect2 xml:id="sec.ha.lvs.ldirectord">
   <title>使用 YaST 設定 IP 負載平衡</title>
   <para>
    您可以使用 YaST IP 負載平衡模組設定基於核心的 IP 負載平衡。這是 <systemitem class="daemon">ldirectord</systemitem> 的前端。
   </para>
   <para>
    若要存取 IP 負載平衡對話方塊，請以 <systemitem class="username">root</systemitem> 身分啟動 YaST，然後選取<menuchoice><guimenu>高可用性</guimenu> <guimenu>IP 負載平衡</guimenu></menuchoice>。或者在指令行上使用 <command>yast2 iplb</command> 以 <systemitem class="username">root</systemitem> 身分啟動 YaST 叢集模組。
   </para>
   <para>
    YaST 會將其組態寫入 <filename>/etc/ha.d/ldirectord.cf</filename>。YaST 模組中可用的索引標籤與 <filename>/etc/ha.d/ldirectord.cf</filename> 組態檔案的結構對應，用於定義全域選項和虛擬服務的選項。
   </para>
   <para>
    如需組態以及所產生之負載平衡器與實際伺服器間程序的範例，請參閱<xref linkend="ex.ha.lvs.ldirectord"/>。
   </para>
   <note>
    <title>全域參數和虛擬伺服器參數</title>
    <para>
     如果同時在虛擬伺服器區段和全域區段指定了某個參數，則虛擬伺服器區段中定義的值將覆寫全域區段中定義的值。
    </para>
   </note>
   <procedure xml:id="sec.ha.lvs.ldirectord.global">
    <title>設定全域參數</title>
    <para>
     以下程序介紹如何設定最重要的全域參數。如需個別參數和此處未涉及之參數的詳細資料，請按一下<guimenu>說明</guimenu>或參閱 <systemitem class="daemon">ldirectord</systemitem> man 頁面。
    </para>
    <step>
     <para>
      使用<guimenu>檢查間隔時間</guimenu>定義 <systemitem class="daemon">ldirectord</systemitem> 連接各個實際伺服器以檢查它們是否連接的時間間隔。
     </para>
    </step>
    <step>
     <para>
      使用<guimenu>檢查逾時</guimenu>設定實際伺服器應在上次檢查後的多少時間內給於回應。
     </para>
    </step>
    <step>
     <para>
      使用<guimenu>失敗計數</guimenu>可以定義當 <systemitem class="daemon">ldirectord</systemitem> 嘗試向實際伺服器發出多少次要求後即判定檢查失敗。
     </para>
    </step>
    <step>
     <para>
      使用<guimenu>協議逾時</guimenu>可以定義協議檢查的逾時時間 (秒)。
     </para>
    </step>
    <step>
     <para>
      在<guimenu>錯誤回復</guimenu>中，輸入當所有實際伺服器都當機時，Web 服務重新導向到之 Web 伺服器的主機名稱或 IP 位址。
     </para>
    </step>
    <step>
     <para>
      如果希望系統在與實際伺服器的連接狀態發生變更時傳送警示，請在<guimenu>電子郵件警示</guimenu>中輸入有效的電子郵件地址。
     </para>
    </step>
    <step>
     <para>
      使用<guimenu>電子郵件警示頻率</guimenu>可以定義當實際伺服器長時間無法存取時，重新傳送電子郵件警示的間隔時間 (秒)。
     </para>
    </step>
    <step>
     <para>
      在<guimenu>電子郵件警示狀態</guimenu>中，指定出現哪種伺服器狀態時傳送電子郵件警示。如果要定義多種狀態，可以逗號分隔。
     </para>
    </step>
    <step>
     <para>
      使用<guimenu>自動重新載入</guimenu>定義 <systemitem class="daemon">ldirectord</systemitem> 是否應持續監控組態檔案的修改情況。如果設定為<literal>是</literal>，便會在變更後自動重新載入組態。
     </para>
    </step>
    <step>
     <para>
      使用<guimenu>Quiescent</guimenu>參數定義是否要從核心的 LVS 表格中移除發生故障的實際伺服器。如果設定為<guimenu>是</guimenu>，則不會移除出現故障的伺服器。而是將其權值設為 <literal>0</literal>，表示不接受任何新的連接。已建立的連接將保持，直到逾時。
     </para>
    </step>
    <step>
     <para>
      如果要使用不同的路徑來記錄，請在<guimenu>記錄檔案</guimenu>中指定記錄的路徑。依預設，<systemitem class="daemon">ldirectord</systemitem> 會將其記錄檔案寫入 <filename>/var/log/ldirectord.log</filename>。
     </para>
    </step>
   </procedure>
   <figure xml:id="fig.ha.lvs.yast.global">
    <title>YaST IP 負載平衡 — 全域參數</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="yast2_iplb_global.png" width="95%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="yast2_iplb_global.png" width="65%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <procedure xml:id="sec.ha.lvs.ldirectord.virtual">
    <title>設定虛擬服務</title>
    <para>
     您可以透過為各項虛擬服務定義一對參數的方式設定一或多個虛擬服務。以下程序介紹如何為虛擬服務設定最重要的全域參數。如需個別參數和此處未涉及之參數的詳細資料，請按一下<guimenu>說明</guimenu>或參閱 <systemitem class="daemon">ldirectord</systemitem> man 頁面。
    </para>
    <step>
     <para>
      在 YaST IP 負載平衡模組中，切換至<guimenu>虛擬伺服器組態</guimenu>索引標籤。
     </para>
    </step>
    <step>
     <para>
      <guimenu>新增</guimenu>新的虛擬伺服器，或<guimenu>編輯</guimenu>現有的虛擬伺服器。此時會出現一個新的對話方塊並顯示可用的選項。
     </para>
    </step>
    <step>
     <para>
      在<guimenu>虛擬伺服器</guimenu>中輸入以 LVS 形式存取負載平衡器和實際伺服器時所使用的共享虛擬 IP 位址 (IPv4 或 IPv6) 及連接埠。也可以指定主機名稱和服務來代替 IP 位址和連接埠號。或者，也可以使用防火牆標記。防火牆標記是將任意一組 <literal>VIP:連接埠</literal>服務集結到一個虛擬服務的一種方式。
     </para>
    </step>
    <step>
     <para>
      若要指定<guimenu>實際伺服器</guimenu>，需要輸入伺服器的 IP 位址 (IPv4、IPv6 或主機名稱)、連接埠 (或服務名稱) 及轉遞方式。轉遞方式必須是 <literal>gate</literal>、<literal>ipip</literal> 或 <literal>masq</literal>，詳情請參閱<xref linkend="sec.ha.lvs.overview.forwarding"/>。
     </para>
     <para>
      按一下<guimenu>新增</guimenu>按鈕並輸入各個實際伺服器所需的引數。
     </para>
    </step>
    <step>
     <para>
      在<guimenu>檢查類型</guimenu>中，選取測試實際伺服器是否仍在工作時執行的檢查類型。例如，若要傳送請求並檢查回應中是否包含預期字串，請選取「<literal>協議</literal>」。
     </para>
    </step>
    <step xml:id="step.ha.lvs.ldirectord.service">
     <para>
      如果<guimenu>檢查類型</guimenu>已設定為「<literal>協議</literal>」，則還需要定義要監控之服務的類型。從<guimenu>服務</guimenu>下拉式方塊中選取所需的服務類型。
     </para>
    </step>
    <step>
     <para>
      在<guimenu>請求</guimenu>中輸入檢查間隔期間向每部實際伺服器所請求之物件的 URI。
     </para>
    </step>
    <step>
     <para>
      如果要檢查實際伺服器的回應中是否包含某個字串 (<quote>I'm alive</quote>訊息)，請定義要比對的正規表示式。在<guimenu>接收</guimenu>中輸入正規表示式。如果實際伺服器的回應中包含此表示式，說明此實際伺服器正在運行。
     </para>
    </step>
    <step>
     <para>
      根據您在<xref linkend="step.ha.lvs.ldirectord.service"/> 中選取的<guimenu>服務</guimenu>類型，您還需要指定其他參數以進行驗證。切換至<guimenu>驗證類型</guimenu>索引標籤，然後輸入<guimenu>登入名稱</guimenu>、<guimenu>密碼</guimenu>、<guimenu>資料庫</guimenu>或<guimenu>秘密</guimenu>等詳細資料。如需詳細資訊，請參閱 YaST 說明文字或 <systemitem class="daemon">ldirectord</systemitem> man 頁面。
     </para>
    </step>
    <step>
     <para>
      切換至<guimenu>其他</guimenu>索引標籤。
     </para>
    </step>
    <step>
     <para>
      選取用於負載平衡的<guimenu>規劃程式</guimenu>。如需可用之規劃程式的相關資訊，請參閱 <command>ipvsadm(8)</command> man 頁面。
     </para>
    </step>
    <step>
     <para>
      選取要使用的<guimenu>協定</guimenu>。如果虛擬服務指定為 IP 位址和連接埠，則必須是 <literal>tcp</literal> 或 <literal>udp</literal> 協定。如果虛擬服務指定為防火牆標記，則必須是 <literal>fwm</literal> 協定。
     </para>
    </step>
    <step>
     <para>
      根據需要定義其他參數。按一下<guimenu>確定</guimenu>確認您的組態。YaST 會將此組態寫入 <filename>/etc/ha.d/ldirectord.cf</filename>。
     </para>
    </step>
   </procedure>

   <figure xml:id="fig.ha.lvs.yast.virtual">
    <title>YaST IP 負載平衡 — 虛擬服務</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="yast2_iplb_virtual.png" width="95%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="yast2_iplb_virtual.png" width="65%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <example xml:id="ex.ha.lvs.ldirectord">
    <title>簡單的 ldirectord 組態</title>
    <para>
     <xref linkend="fig.ha.lvs.yast.global"/> 和<xref linkend="fig.ha.lvs.yast.virtual"/> 中的顯示的值會產生以下組態 (定義於 <filename>/etc/ha.d/ldirectord.cf</filename>)︰
    </para>
<screen>autoreload = yes <co xml:id="co.ha.ldirectord.autoreload"/>
    checkinterval = 5 <co xml:id="co.ha.ldirectord.checkintervall"/>
    checktimeout = 3 <co xml:id="co.ha.ldirectord.checktimeout"/>
    quiescent = yes <co xml:id="co.ha.ldirectord.quiescent"/>
    virtual = 192.168.0.200:80 <co xml:id="co.ha.ldirectord.virtual"/>
    checktype = negotiate <co xml:id="co.ha.ldirectord.checktype"/>
    fallback = 127.0.0.1:80 <co xml:id="co.ha.ldirectord.fallback"/>
    protocol = tcp <co xml:id="co.ha.ldirectord.protocol"/>
    real = 192.168.0.110:80 gate <co xml:id="co.ha.ldirectord.real"/>
    real = 192.168.0.120:80 gate <xref linkend="co.ha.ldirectord.real" xrefstyle="select:label nopage"/>
    receive = "still alive" <co xml:id="co.ha.ldirectord.receive"/>
    request = "test.html" <co xml:id="co.ha.ldirectord.request"/>
    scheduler = wlc <co xml:id="co.ha.ldirectord.scheduler"/>
    service = http <co xml:id="co.ha.ldirectord.service"/></screen>
    <calloutlist>
     <callout arearefs="co.ha.ldirectord.autoreload">
      <para>
       定義 <systemitem class="daemon">ldirectord</systemitem> 應持續檢查組態檔案的修改情況。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.checkintervall">
      <para>
       <systemitem class="daemon">ldirectord</systemitem> 連接各個實際伺服器以檢查它們是否連接的時間間隔。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.checktimeout">
      <para>
       自上次檢查後，實際伺服器應做出回應的時間。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.quiescent">
      <para>
       指定不要將發生故障的實際伺服器從核心的 LVS 表格中移除，但將其權值設為 <literal>0</literal>。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.virtual">
      <para>
       LVS 的虛擬 IP 位址 (VIP)。LVS 可使用連接埠 <literal>80</literal> 進行連接。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.checktype">
      <para>
       為測試實際伺服器是否仍在工作而執行的檢查類型。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.fallback">
      <para>
       所有實際伺服器都當機時，將 Web 服務重新導向到的伺服器。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.protocol">
      <para>
       要使用的協定。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.real">
      <para>
       兩個已定義的實際伺服器，可使用連接埠 <literal>80</literal> 連接。封包轉遞方式是 <literal>gate</literal>，表示使用直接路由。
      </para>
     </callout>

     <callout arearefs="co.ha.ldirectord.receive">
      <para>
       要在實際伺服器之回應字串中比對的正規表示式。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.request">
      <para>
       檢查間隔期間向每部實際伺服器所請求之物件的 URI。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.scheduler">
      <para>
       所選的用於負載平衡的規劃程式。
      </para>
     </callout>
     <callout arearefs="co.ha.ldirectord.service">
      <para>
       要監控的服務類型。
      </para>
     </callout>
    </calloutlist>
    <para>
     此組態會產生以下程序流︰<systemitem class="daemon">ldirectord</systemitem> 將每隔 5 秒 (<xref linkend="co.ha.ldirectord.checkintervall" xrefstyle="select:label nopage"/>) 連接一次各個實際伺服器，並請求<xref linkend="co.ha.ldirectord.real" xrefstyle="select:label nopage"/> 和<xref linkend="co.ha.ldirectord.request" xrefstyle="select:label nopage"/> 中指定的 <literal>192.168.0.110:80/test.html</literal> 或 <literal>192.168.0.120:80/test.html</literal>。如果最後一次檢查時，3 秒內 (<xref linkend="co.ha.ldirectord.checktimeout" xrefstyle="select:label nopage"/>) 未從某部實際伺服器收到預期的 <literal>still alive</literal> 字串 (<xref linkend="co.ha.ldirectord.receive" xrefstyle="select:label nopage"/>)，則會將該實際伺服器從可用池中移除。但是，由於設定了 <literal>quiescent=yes</literal> (<xref linkend="co.ha.ldirectord.quiescent" xrefstyle="select:label nopage"/>)，因此該實際伺服器不會從 LVS 表中移除。其權數會設定為 <literal>0</literal>，這樣便不會接受與此實際伺服器的新連接。已建立的連接將保持，直到逾時。
    </para>
   </example>
  </sect2>

  <sect2 xml:id="sec.ha.lvs.further">
   <title>更多設定</title>
   <para>
    除了需要使用 YaST 設定 <systemitem class="daemon">ldirectord</systemitem> 組態之外，您還需要確定以下條件均已符合才能完成 LVS 的設定︰
   </para>
   <itemizedlist>
    <listitem>
     <para>
      已正確設定實際伺服器以提供所需的服務。
     </para>
    </listitem>
    <listitem>
     <para>
      一或多個負載平衡伺服器必須能夠採用 IP 轉遞方式將流量路由到實際伺服器。實際伺服器的網路組態取決於您選擇的封包轉遞方法。
     </para>
    </listitem>
    <listitem>
     <para>
      為了防止一或多個負載平衡伺服器成為整個系統的單一故障點，需要設定一或多個負載平衡器的備份。在叢集組態中，設定 <systemitem class="daemon">ldirectord</systemitem> 的基本資源，這樣在出現硬體故障時，<systemitem class="daemon">ldirectord</systemitem> 便可容錯移轉到其他伺服器。
     </para>
    </listitem>
    <listitem>
     <para>
      由於負載平衡器的備份也需要 <systemitem class="daemon">ldirectord</systemitem> 組態檔案來完成此任務，因此請確定要用做負載平衡器之備份的所有伺服器上，<filename>/etc/ha.d/ldirectord.cf</filename> 均可用。您可以依照<xref linkend="sec.ha.installation.setup.csync2"/> 所述使用 Csync2 同步組態檔案。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.ha.lb.haproxy">
  <title>使用 HAProxy 設定負載平衡</title>

  <remark>
   This is a straightforward explanation how to set up a HA openSUSE
   13.1 http load balancer, but not using SLE HA tools, but plain
   vanilla openSUSE with vi.
  
  </remark>

  <para>
   下面的部分提供了 HAProxy 的綜覽，並介紹了如何在 High Availability 上進行設定。負載平衡器會將所有要求配送至其後端伺服器。它設定為主動/被動模式，也就是說，當主要節點失敗時，從屬節點就會變成主要節點。在這種情況下，使用者感受不到任何服務中斷的跡象。
  </para>

  <para>
   在本節中，我們將使用以下設定：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     兩個負載平衡器：alice 和 bob，其 IP 位址分別為 <systemitem class="ipaddress">192.168.1.100</systemitem> 和 <systemitem class="ipaddress">192.168.1.101</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     一個虛擬浮動 IP 位址 <systemitem class="ipaddress">192.168.1.99</systemitem>
    </para>
   </listitem>
   <listitem>
    <para>
     伺服器 (通常用於代管 Web 內容) <systemitem class="server">www1.example.com</systemitem> (IP：<systemitem class="ipaddress">192.168.1.200</systemitem>) 和 <systemitem class="server">www2.example.com</systemitem> (IP：<systemitem class="ipaddress">192.168.1.201</systemitem>)
    </para>
   </listitem>
  </itemizedlist>

  <para>
   若要設定 HAProxy，請執行以下程序︰
  </para>

  <procedure>
   <step>
    <para>
     安裝 <systemitem class="resource">haproxy</systemitem> 套件。
    </para>
   </step>
   <step>
    <para>
     建立包含以下內容的 <filename>/etc/haproxy/haproxy.cfg</filename> 檔案：
    </para>

    <remark>toms 2014-09-17: Not sure about all the options.</remark>
<screen>global <co xml:id="co.ha.lb.global"/>
  maxconn 256
  daemon

defaults <co xml:id="co.ha.lb.defaults"/>
  log     global
  mode    http
  option  httplog
  option  dontlognull
  retries 3
  option redispatch
  maxconn 2000
  timeout connect   5000  <co xml:id="co.ha.lb.timeout.connect"/>
  timeout client    50s   <co xml:id="co.ha.lb.timeout.client"/>
  timeout server    50000 <co xml:id="co.ha.lb.timeout.server"/>

  bind 192.168.1.99:80 <co xml:id="co.ha.lb.listen"/>
  mode http
  stats enable
  stats uri /haproxy?stats
  stats auth someuser:somepassword
  balance leastconn
  cookie JSESSIONID prefix
  option httpclose
  option forwardfor
  option httpchk GET /robots.txt HTTP/1.0
  server webA 192.168.1.200:80 cookie A check
  server webB 192.168.1.201:80 cookie B check</screen>
    <calloutlist>
     <callout arearefs="co.ha.lb.global">
      <para>
       包含程序範圍選項和作業系統特定選項的區段。
      </para>
      <variablelist>
       <varlistentry>
        <term><option>maxconn</option>
        </term>
        <listitem>
         <para>
          每個程序的最大同時連接數。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>daemon</option>
        </term>
        <listitem>
         <para>
          建議的模式，HAProxy 將在背景中執行。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </callout>
     <callout arearefs="co.ha.lb.defaults">
      <para>
       用於為位於其宣告之後的所有其他區段設定預設參數的區段。一些重要的行：
      </para>
      <variablelist>
       <varlistentry>
        <term><option>redispatch</option>
        </term>
        <listitem>
         <para>
          啟用或停用在連接失敗時重新配送工作階段的功能。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>log</option>
        </term>
        <listitem>
         <para>
          啟用事件和流量記錄。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>mode http</literal>
        </term>
        <listitem>
         <para>
          以 HTTP 模式運作 (針對 HAProxy 建議的模式)。在此模式下，在連接到任一伺服器之前會先分析要求。不符合 RFC 的要求將會遭到拒絕。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>option forwardfor</literal>
        </term>
        <listitem>
         <para>
          將 HTTP <option>X-Forwarded-For</option> 標頭新增至要求中。如果您想要保留用戶端的 IP 位址，則需要使用此選項。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </callout>
     <callout arearefs="co.ha.lb.timeout.connect">
       <para>成功嘗試與伺服器建立連接之前可以等待的最長時間。
       </para>
     </callout>
     <callout arearefs="co.ha.lb.timeout.client">
       <para>用戶端可保持非活動狀態的最長時間。</para>
     </callout>
     <callout arearefs="co.ha.lb.timeout.server">
       <para>伺服器端可保持非活動狀態的最長時間。</para>
     </callout>
     <callout arearefs="co.ha.lb.listen">
      <para>
       在該區段中，前端區段和後端區段合併成一個區段。
      </para>
      <variablelist>
       <varlistentry>
        <term><literal>balance leastconn</literal>
        </term>
        <listitem>
         <para>
          定義負載平衡演算法，請參閱 <link xlink:href="http://cbonte.github.io/haproxy-dconv/configuration-1.5.html#4-balance"/>。
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term><literal>stats enable</literal>
        </term>
        <term><literal>stats auth</literal>
        </term>
        <listitem>
         <para>
          啟用統計報告 (透過 <literal>stats enable</literal>)。<option>auth</option> 選項記錄有關特定帳戶的驗證的統計資料。
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </callout>
    </calloutlist>
   </step>
   <step>
    <para>
     測試組態檔案：
    </para>
<screen><prompt role="root">root # </prompt><command>haproxy</command> -f /etc/haproxy/haproxy.cfg -c</screen>
   </step>
   <step>
    <para>
     將以下行新增至 Csync2 的組態檔案 <filename>/etc/csync2/csync2.cfg</filename> 中，以確定包括 HAProxy 組態檔案：
    </para>
<screen>include /etc/haproxy/haproxy.cfg</screen>
   </step>
   <step>
    <para>
     同步該檔案：
    </para>
<screen><prompt role="root">root # </prompt><command>csync2</command> -f /etc/haproxy/haproxy.cfg
<prompt role="root">root # </prompt><command>csync2</command> -xv</screen>
    <note>
     <para>
      Csync2 組態部分假設 HA 節點是使用 <command>ha-cluster-bootstrap</command> 設定的。如需詳細資料，請參閱<xref linkend="sec.ha.installation.setup.auto"/>。
     </para>
    </note>
   </step>
   <step>
    <para>
     務必在兩個負載平衡器 (<systemitem class="server">alice</systemitem> 和 <systemitem class="server">bob</systemitem>) 上都停用 HAProxy，因為它會由 Pacemaker 啟動：
    </para>
<screen><prompt role="root">root # </prompt><command>systemctl</command> disable haproxy</screen>
   </step>
   <step>
    <para>
     設定新的 CIB：
    </para>
    <remark>toms 2014-09-16: According to Kristoffer: "This is the crmsh 
       configuration (edited using crm configure). It is possible to do a 
       similar configuration in hawk, but with the graphical interface.
       I think it can be improved, I will get back to you with more details 
       :)"</remark>
<screen><prompt role="root">root # </prompt><command>crm</command> configure
<prompt role="custom">crm(live)# </prompt><command>cib</command> new haproxy-config
<prompt role="custom">crm(haproxy-config)# </prompt><command>primitive</command> haproxy systemd:haproxy op monitor interval=10s
<prompt role="custom">crm(haproxy-config)# </prompt><command>primitive</command> vip-www1 IPaddr2 params ip=192.168.1.100
<prompt role="custom">crm(haproxy-config)# </prompt><command>primitive</command> vip-www2 IPaddr2 params ip=192.168.1.101
<prompt role="custom">crm(haproxy-config)# </prompt><command>group</command> g-haproxy vip-www1 vip-www2 haproxy</screen>
   </step>
   <step>
    <para>
     驗證新 CIB 並修正任何錯誤：
    </para>
<screen><prompt role="custom">crm(haproxy-config)# </prompt><command>verify</command></screen>
   </step>
   <step>
    <para>
     提交新的 CIB：
    </para>
<screen><prompt role="custom">crm(haproxy-config)# </prompt><command>cib</command> use live
<prompt role="custom">crm(live)# </prompt><command>cib</command> commit haproxy-config</screen>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec.ha.lb.more">
  <title>更多資訊</title>

  <itemizedlist>
    <listitem>
      <para><link xlink:href="http://www.haproxy.org"/></para>
    </listitem>
    <listitem>
      <para>專案首頁 <link xlink:href="http://www.linuxvirtualserver.org/"/>。
  </para>
    </listitem>
    <listitem>
      <para>如需有關 <systemitem class="daemon">ldirectord</systemitem> 的資訊，請參閱完整的 man 頁面。</para>
    </listitem>
    <listitem>
      <para>LVS 知識庫：<link xlink:href="http://kb.linuxvirtualserver.org/wiki/Main_Page"/></para>
    </listitem>
  </itemizedlist>
 </sect1>
</chapter>
