<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="ha_storage_protection.xml" version="5.0" xml:id="cha.ha.storage.protect">
 <title>ストレージ保護</title>
 <info>
      <abstract>
        
        <para>
    この章では、ストレージ自体を活用するIOフェンシングについて説明し、次に、排他的ストレージアクセスを確保する追加保護レイヤについて説明します。これら2つのメカニズムを組み合わせると、より高度な保護を実現できます。
   </para>
      </abstract>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:maintainer/>
        <dm:status>編集</dm:status>
        <dm:deadline/>
        <dm:priority/>
        <dm:translation>yes</dm:translation>
        <dm:languages/>
        <dm:release/>
        <dm:repository/>
      </dm:docmanager>
    </info>
    <sect1 xml:id="sec.ha.storage.overview">
      <title>概念の概要</title>
      <para>SBDは、「Storage-Based Death」または「STONITHブロックデバイス」の略語です。<emphasis/><emphasis/></para>
      
      <para>
        High Availabilityクラスタスタックでは、データの整合性の保護が最優先されます。これは、データストレージへの未調整の同時アクセスを防止することによって達成されます。たとえば、Ext3ファイルシステムは、クラスタに一回だけマウントされ、OCFS2ボリュームは、他のクラスタノードとの調整が可能になるまでマウントされません。正常に機能するクラスタでは、Pacemakerによって、リソースがそれらの同時並行性の制限を超えてアクティブであるかどうかが検出され、復元が開始されます。さらに、そのポリシーエンジンがそれらの制限を超えることは決してありません。
      </para>
      <para>
        ただし、ネットワークのパーティション分割やソフトウェアの誤動作により、いくつものコーディネータが選択される状況となる可能性があります。このいわゆるスプリットブレインシナリオが発生した場合は、データが破損することがあります。したがって、このリスクを軽減するため、クラスタスタックには、いくつもの保護レイヤが追加されています。
      </para>
      <para>
        この目的に貢献する第一のコンポーネントは、ノードフェンシング/STONITHです。これにより、ストレージアクティベーション以前の他のすべてのアクセスが確実に終了されるからです。その他のメカニズムとしては、管理やアプリケーションの欠陥に対してシステムを保護するcLVM2の排他的アクティベーションやOCFS2のファイルロッキングサポートがあります。これらをご使用のセットアップに適合するように組み合わせると、スプリットブレインシナリオの悪影響を確実に防止できます。
      </para>
  </sect1>

  <sect1 xml:id="sec.ha.storage.protect.fencing">
  <title>ストレージベースのフェンシング</title>
  <para>
   1つ以上のSTONITHブロックデバイス(SBD)、<literal>watchdog</literal>サポート、<literal>external/sbd</literal> STONITHエージェントを使用することで、スプリットブレインシナリオを確実に回避することができます。
  </para>

  <sect2 xml:id="sec.ha.storage.protect.fencing.oview">
   <title>概要</title>
   <para>
    すべてのノードが共有ストレージへのアクセスを持つ環境で、デバイスの小さなパーティションをSBDで使用できるようにフォーマットします。パーティションのサイズは、使用されるディスクのブロックサイズによって異なります(512バイトのブロックサイズの標準SCSIディスクには1MB、4KBブロックサイズのDASDディスクには4MB必要です)。SBDは、そのデーモンの設定後、クラスタスタックの他のコンポーネントが起動される前に各ノードでオンラインになります。SBDデーモンは、他のすべてのクラスタコンポーネントがシャットダウンされた後で終了されます。したがって、クラスタリソースがSBDの監督なしでアクティブになることはありません。
   </para>
   <para>
    このデーモンは、自動的に、パーティション上のメッセージスロットの1つを自分自身に割り当て、自分へのメッセージがないかどうか、そのスロットを絶えず監視します。デーモンは、メッセージを受信すると、ただちに要求に従います(フェンシングのための電源切断や再起動サイクルの開始など)。
   </para>
   <para>
    デーモンは、ストレージデバイスへの接続性を絶えず監視し、パーティションが到達不能になった場合は、デーモン自体が終了します。このため、デーモンがフェンシングメッセージから切断されることはありません。これは、クラスタデータが別のパーティション上の同じ論理ユニットにある場合、追加障害ポイントになることはありません。ストレージ接続を失えば、ワークロードは終了します。
   </para>
   <para>
    ウォッチドッグを使用してSBDを組み合わせることで、保護を強化します。SBDを使用する場合は常に、正常動作するウォッチドッグが不可欠です。近代的なシステムは、ソフトウェアコンポーネントによって<quote>チックル</quote>または<quote>フィード</quote>される必要のある<literal>hardware watchdog</literal>をサポートします。ソフトウェアコンポーネント(通常はデーモン)は、watchdogに定期的にサービスパルスを書き込みます。デーモンがwatchdogへのフィードを停止する場合、ハードウェアはシステムの再起動を強制します。この機能は、SBDプロセス自体の障害(IOエラーで終了またはスタックするなど)に対する保護を提供します。
   </para>
   <para>
    Pacemaker統合が有効になっている場合、デバイスの過半数が失われてもSBDはセルフフェンスを行いません。たとえば、クラスタにA、B、Cの3つのノードが含まれており、ネットワーク分割によってAには自分自身しか表示できず、BとCはまだ通信可能な状態であるとします。この場合、2つのクラスタパーティションが存在し、1つは過半数(B、C)であるためにクォーラムがあり、もう1つにはクォーラムがない(A)ことになります。過半数のフェンシングデバイスに到達できないときにこれが発生した場合、ノードAはすぐに自らダウンしますが、BとCは引き続き実行されます。
   </para>
  </sect2>

  <sect2 xml:id="sec.ha.storage.protect.req">
    <title>要件</title>
    <para>
     SBDは<emphasis/>「共有」ストレージデバイスを必要とするか、ディスクレスモードで操作できるかのどちらかです。次の要件を考慮に入れる必要があります。
    </para>
      <itemizedlist>
        <listitem>
          <para>環境内にすべてのノードが到達できる共有ストレージが存在する必要があります。 </para>
        </listitem>
        <listitem>
          <para>SBDは一切のデバイスを使用できない(ディスクレスモード)か、3デバイスまで使用できます(詳細は、<xref linkend="sec.ha.storage.protect.fencing.number"/>を参照してください)。</para>
        </listitem>
        <listitem>
          <para>共有ストレージはFC (ファイバチャネル)、FCoE (Fibre Channel over Ethernet)、またはiSCSI経由で接続できます。 </para>
        </listitem>
        <listitem>
          <para> 共有ストレージセグメントが、ホストベースのRAID、cLVM2、またはDRBD*を「使用してはなりません」。<emphasis/>DRBDは分割できますが、SBDでは2つの状態が存在することはできないため、これはSBDにとって問題になります。
          </para>
        </listitem>
        <listitem>
          <para> ただし、信頼性向上のため、ストレージベースのRAIDとマルチパスの使用は推奨されます。 </para>
        </listitem>
        <listitem>
          <para>255を超えるノードでデバイスを共有しない限り、異なるクラスタ間でSBDデバイスを共有できます。 </para>
        </listitem>
      </itemizedlist>
  </sect2>



  <sect2 xml:id="sec.ha.storage.protect.fencing.number">
   <title>SBDデバイスの数</title>
   <para>
    SBDは、1～3台のデバイスの使用をサポートします。
   </para>
   <variablelist>
    <varlistentry>
     <term>ディスクレス</term>
     <listitem>
      <para>この設定は、共有ストレージなしのフェンシングメカニズムが必要なときに便利です。このディスクレスモードでは、SBDは共有デバイスに頼らず、ハードウェアウォッチドッグを使用してノードをフェンスします。ただし、ディスクレスSBDは2ノードクラスタ用のスプリットブレインシナリオには対応できません。そのため、ディスクレスSBDを使用するには、3以上のノードが必要です。</para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1台のデバイス</term>
     <listitem>
      <para>
       最も単純な実装です。すべてのデータが同じ共有ストレージ上にあるクラスタに適しています。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>2台のデバイス</term>
     <listitem>
      <para>
       この設定は、主に、ホストベースのミラーリングを使用しているものの3つ目のストレージデバイスが使用できない環境で役立ちます。1つのミラーログにアクセスできなくなっても、SBDは終了せず、クラスタは引き続き実行できます。ただし、SBDにはストレージの非同期分割を検出できるだけの情報が与えられていないので、ミラーログが1つだけ使用可能なときにもう一方をフェンスすることはありません。つまり、ストレージアレイのいずれかがダウンしたときに、2つ目の障害に自動的に耐えることはできません。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>3台のデバイス</term>
     <listitem>
      <para>
       最も信頼性の高い設定です。障害または保守による1台のデバイスの機能停止から回復できます。SBDは複数のデバイスが失われた場合のみ自らを終了させます。2つ以上のデバイスにまだアクセス可能であれば、フェンシングメッセージを正しく送信することができます。
      </para>
      <para>
       この設定は、ストレージが1つのアレイに制約されていない、比較的複雑なシナリオに適しています。ホストベースのミラーリングソリューションでは、1つのミラーログに1つのSBDを設定し(自分自身はミラーしない)、iSCSI上に追加のタイブレーカを設定できます。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec.ha.storageprotection.fencing.setup">
   <title>ストレージベースの保護のセットアップ</title>
   <para>
    ストレージベースの保護を設定するには、次の手順に従う必要があります。
   </para>
   <procedure>
    <step>
       <para>
         <xref linkend="pro.ha.storage.protect.watchdog" xrefstyle="select:title"/>
       </para>
    </step>
    <step>
     <para>
      <xref linkend="pro.ha.storage.protect.sbd.create" xrefstyle="select:title"/>
     </para>
    </step>
    <step>
     <para>
      <xref linkend="pro.ha.storage.protect.sbd.daemon" xrefstyle="select:title"/>
     </para>
    </step>
    <step>
     <para>
      <xref linkend="pro.ha.storage.protect.sbd.test" xrefstyle="select:title"/>
     </para>
    </step>
    <step>
     <para>
      <xref linkend="pro.ha.storage.protect.fencing" xrefstyle="select:title"/>
     </para>
    </step>
   </procedure>
   <para>
    次の手順は、すべて<systemitem class="username">root</systemitem>として実行する必要があります。手順を開始する前に、次の要件が満たされているかどうか確認してください。
   </para>

    <sect3 xml:id="sec.ha.storage.protect.watchdog">
      <title>ウォッチドッグのセットアップ</title>
      <para> <phrase role="productname"><phrase os="sles">SUSE Linux Enterprise High Availability Extension</phrase></phrase>では、カーネル内のウォッチドッグサポートはデフォルトで有効化されています。これは、ハードウェア指定のウォッチドッグドライバを提供する、さまざまなカーネルモジュールを標準装備しています。High Availability Extensionはウォッチドッグに<quote>フィード</quote>するソフトウェアコンポーネントとしてSBDデーモンを使用します。<xref linkend="pro.ha.storage.protect.sbd.daemon"/>で説明されているとおりに設定した場合、それぞれのノードを<command>systemctl</command>
          <option> start pacemaker</option>でオンラインにする際に、SBDデーモンが自動的に開始されます。 </para>
      <important>
        <title>ウォッチドッグタイマへのアクセス</title>
        <para>
          他のソフトウェアは、ウォッチドッグタイマにアクセスしないでください。一部のハードウェアベンダーは、システムのリセット用にウォッチドッグを使用するシステム管理ソフトウェアを提供しています(たとえば、HP ASRデーモンなど)。ウォッチドッグをSBDで使用する場合は、そのようなソフトウェアを無効にしてください。
        </para>
      </important>

      <para>特定のシステムの正しいカーネルモジュールを判断することは、必ずしも容易ではありません。非常に多くの場合、これは自動プローブが失敗する原因になります。その結果、正しいモジュールがロードされる前に、多くのモジュールがすでにロードされている状態になってしまいます。次の手順は、適切なウォッチドッグドライバをロードするための実証済みの解決策です。
      </para>

      <remark>toms 2015-10-05: Mostly inspired, taken, and adapted from
        https://www.suse.com/support/kb/doc.php?id=7016880</remark>
      <procedure xml:id="pro.ha.storage.protect.watchdog">
       <title>ウォッチドッグのセットアップ</title>
        <step xml:id="st.ha.storage.determine.watchdog-module">
          <para>正しいウォッチドッグモジュールを判断します。</para>
          <substeps>
            <step>
              <para>次の表からドライバ名を取得します。</para>
              <table xml:id="tab.ha.storage.protect.watchdog.drivers">
                <title>一般的に使用されるウォッチドッグドライバの簡略リスト</title>
                <tgroup cols="2">
                  <thead>
                    <row>
                      <entry>Hardware (ハードウェア)</entry>
                      <entry>ドライバ</entry>
                    </row>
                  </thead>
                  <tbody>
                    <row>
                      <entry>HP</entry>
                      <entry><systemitem class="resource">hpwdt</systemitem></entry>
                    </row>
                    <row>
                      <entry>Dell、Fujitsu、Lenovo (Intel TCO)</entry>
                      <entry><systemitem class="resource">iTCO_wdt</systemitem></entry>
                    </row>
                    <row>
                      <entry>IBMメインフレーム上のz/VMのVM</entry>
                      <entry><systemitem class="resource">vmwatchdog</systemitem></entry>
                    </row>
                    <row>
                      <entry>Xen VM (DomU)</entry>
                      <entry><systemitem class="resource">xen_xdt</systemitem></entry>
                    </row>
                    <row>
                      <entry>Generic</entry>
                      <entry><systemitem class="resource">softdog</systemitem></entry>
                    </row>
                  </tbody>
                </tgroup>
              </table>
            </step>
            <step>
              <para>ご使用のハードウェアが<xref linkend="tab.ha.storage.protect.watchdog.drivers"/>に記載されていない場合は、ディレクトリ<filename>/lib/modules/<replaceable>KERNEL_VERSION</replaceable>/kernel/drivers/watchdog</filename>で選択肢のリストを調べるか、ハードウェアベンダーに正しい名前を問い合わせてください。
              </para>
              <para>
                または、次のコマンドで、ご使用のカーネルバージョンでインストールされたドライバを一覧表示します。
              </para>
              <screen><prompt role="root">root # </prompt><command>rpm</command> -ql kernel-<replaceable>VERSION</replaceable> | <command>grep</command> watchdog</screen>
            </step>
            <step xml:id="st.ha.storage.listwatchdog.modules">
              <para>ロードされているウォッチドッグモジュールを一覧にし、それらをアンロードします。</para>
              <screen><prompt role="root">root # </prompt><command>lsmod</command> | <command>egrep</command> "(wd|dog)"</screen>
              <para>結果が表示されたら、間違ったモジュールをアンロードします。</para>
              <screen><prompt role="root">root # </prompt><command>rmmod</command> <replaceable>WRONG_MODULE</replaceable></screen>
            </step>
          </substeps>
        </step>
       <step>
        <para>
         <xref linkend="st.ha.storage.determine.watchdog-module"/>からウォッチドッグモジュールを有効にします。
        </para>
        <screen><prompt role="root">root # </prompt><command>echo</command> <replaceable>WATCHDOG_MODULE</replaceable> &gt; /etc/modules-load.d/watchdog.conf
<prompt role="root">root # </prompt><command>systemctl</command> restart systemd-modules-load</screen>
       </step>
        <step>
          <para>ウォッチドッグモジュールが正しくロードされているかどうかをテストします。</para>
          <screen><prompt role="root">root # </prompt><command>lsmod</command> | <command>grep</command> dog</screen>
        </step>
      </procedure>
  </sect3>
    
  <sect3 xml:id="pro.ha.storage.protect.sbd.create">
    <title>SBDパーティションの作成</title>
    <para>
     デバイスの起動時に1MBのパーティションを作成することを推奨します。SBDデバイスがマルチパスグループ上にある場合は、MPIO (マルチパスI/O)のパスダウン検出によって遅延が発生することがあるので、SBDが使用するタイムアウトを調整する必要があります。</para>
     <para><literal>msgwait</literal>タイムアウト後、メッセージがノードに配信されたと想定されます。この時間は、マルチパスの場合、MPIOがパスの障害を検出し、次のパスに切り替えるために必要な時間です。つまり、<filename>/etc/multipath.conf</filename>の<literal>max_polling_interval</literal>は、<literal>watchdog</literal>のタイムアウト値より小さい値でなくてはなりません。これは、ご使用の環境でテストする必要があるかもしれません。</para>
     <para>ノード上で実行しているSBDデーモンがウォッチドッグタイマを十分な速さで更新していない場合、ノード自体が終了します。選択したタイムアウトを特定の環境でテストします。1台のSBDデバイスしかないマルチパスストレージを使用する場合は、発生したフェールオーバーの遅延に特別の注意を払ってください。
    </para>
    <important>
     <title>既存データの上書き</title>
     <para>
      SBD用に使用するデバイスには、重要なデータが一切ないようにしてください。<command>sdb</command>コマンドは、さらに確認を要求せずに、デバイスを上書きします。
     </para>
    </important>
    <procedure>
     <step>
       <para>SBDデバイスとして使用するブロックデバイスを決定します。このSBDデバイスには、論理ユニット、パーティション、または論理ボリュームを使用できます。そのブロックデバイスに関係なく、SBDデバイスはすべてのノードからアクセス可能である必要があります。
       </para>
     </step>
     <step>
      <para>
       次のコマンドでSBDデバイスを初期化します(<filename>/dev/<replaceable>SBD</replaceable></filename>は実際のパス名に置き換えます。たとえば、<filename>/dev/disk/by-id/scsi-ST2000DM001-0123456_Wabcdefg</filename>です)。
      </para>
<screen><prompt role="root">root # </prompt><command>sbd</command> -d /dev/<replaceable>SBD</replaceable> create</screen>
      <para>
       これによって、デバイスにヘッダが書き込まれ、デフォルトのタイミングでこのデバイスを共有する最大255ノードのスロットが作成されます。
      </para>
      <para>
       SBD用に複数のデバイスを使用する場合は、次のように、<option>-d</option>オプションを複数回指定することでデバイスを設定します。
      </para>
<screen><prompt role="root">root # </prompt><command>sbd</command> -d /dev/<replaceable>SBD1</replaceable> -d /dev/<replaceable>SBD2</replaceable> -d /dev/<replaceable>SBD3</replaceable> create</screen>
     </step>
     <step>
      <para>
       SBDデバイスがマルチパスグループ上にある場合は、SBDが使用するタイムアウトを調整します。これは、SBDデバイスの初期化時に指定できます(すべてのタイムアウトは秒単位で指定)。
      </para>

<screen><prompt role="root">root # </prompt><command>sbd</command> -d /dev/<replaceable>SBD</replaceable> -4 180<co xml:id="co.msgwait"/> -1 90<co xml:id="co.watchdog"/> create</screen>
      <calloutlist>
       <callout arearefs="co.msgwait">
        <para>
         <option>-4</option>オプションは<literal>msgwait</literal>タイムアウトを指定するために使用されます。上の例では、<literal>180</literal>秒に設定されます。
        </para>
       </callout>
       <callout arearefs="co.watchdog">
        <para>
         <option>-1</option>オプションは<literal>watchdog</literal>タイムアウトを指定するために使用されます。上の例では、<literal>90</literal>秒に設定されます。エミュレートされたウォッチドッグで使用可能な最小値は<literal>15</literal>秒です。
        </para>
       </callout>
      </calloutlist>
     </step>
     <step>
      <para>
       次のコマンドで、デバイスに何が書き込まれたか確認します。
      </para>
<screen><prompt role="root">root # </prompt><command>sbd</command> -d /dev/<replaceable>SBD</replaceable> dump 
Header version     : 2
Number of slots    : 255
Sector size        : 512
Timeout (watchdog) : 5
Timeout (allocate) : 2
Timeout (loop)     : 1
Timeout (msgwait)  : 10</screen>
     </step>
    </procedure>
    <para>
     ご覧のように、タイムアウトがヘッダにも保存され、それらに関するすべての参加ノードの合意が確保されます。
    </para>
   </sect3>

  <sect3 xml:id="sec.ha.storage.protect.watchdog.timings">
    <title>ウォッチドッグのタイミングの設定</title>
      <para>
        エミュレートされたウォッチドッグで使用可能な最小値は<literal>15</literal>秒です。ウォッチドッグのタイムアウトを変更する場合は、他の2つの値(<literal>msgwait</literal>および<literal>stonith-timeout</literal>)も変更する必要があります。ウォッチドッグタイムアウトは主に、ストレージレイテンシに基づくものです。この値は、ほとんどのデバイスで、このタイムフレーム内に読み込み操作を正常に完了する必要があることを指定しています。完了しない場合、ノードは自己フェンシングします。
      </para>
      <para>
        次の<quote/>式は、これら3つの値の関係を簡潔に示しています。
      </para>
      <example xml:id="ex.ha.storage.protect.sbd-timings">
        <title>STONITHデバイスとしてSBDを使用したクラスタのタイミング</title>
        <screen>Timeout (msgwait) = (Timeout (watchdog) * 2)
stonith-timeout = Timeout (msgwait) + 20%</screen>
      </example>
      <para>
        たとえば、タイムアウトウォッチドッグを120に設定した場合は、<literal>msgwait</literal>を240に、<literal>stonith-timeout</literal>を288に設定する必要があります。<command>sbd</command>により出力を確認できます。
      </para>
      <screen><prompt role="root">root # </prompt><command>sbd</command> -d /dev/<replaceable>SBD</replaceable> dump
==Dumping header on disk /dev/sdb
Header version     : 2.1
UUID               : 619127f4-0e06-434c-84a0-ea82036e144c
Number of slots    : 255
Sector size        : 512
Timeout (watchdog) : 20
Timeout (allocate) : 2
Timeout (loop)     : 1
Timeout (msgwait)  : 40
==Header on disk /dev/sdb is dumped</screen>
      <para>
        新しいクラスタをセットアップした場合は、<command>ha-cluster-init</command>コマンドで、先に示した考慮事項を反映できます。
      </para>
    </sect3>

   <sect3 xml:id="pro.ha.storage.protect.sw-watchdog">
    <title>softdogウォッチドッグのセットアップ</title>
    <important>
     <title>softdogの制限</title>
     <para>softdogドライバはCPUが最低1つは動作中であることを前提とします。すべてのCPUが固まっている場合、システムを再起動させるsoftdogドライバのコードは実行されません。これに対して、ハードウェアウォッチドッグはすべてのCPUが固まっていても動作し続けます。</para>
     <para>ご使用のハードウェアに最適なハードウェアウォッチドッグを使用することを強くお勧めします。ただし、ハードウェアに適合するウォッチドッグがない場合、カーネルウォッチドッグモジュールとして<systemitem class="resource">softdog</systemitem>を使用することができます。</para>
    </important>
    <para>ソフトウェアウォッチドッグを有効にするには、次の手順を使用します。</para>
     <procedure>
       <step>
         <para>次の行を<filename>/etc/init.d/boot.local</filename>に追加します。</para>
         <screen>modprobe softdog</screen>
       </step>
       <step>
         <para>ファイル<filename>/etc/sysconfig/sbd</filename>を開きます。</para>
         <screen>SBD_DEVICE="/dev/<replaceable>SBD</replaceable>"</screen>
         <para>デバイスが複数ある場合は、セパレータとしてセミコロンを使用します。</para>
       </step>
       <step>
         <para>SBDデーモンをテストします。</para>
         <screen><prompt role="root">root # </prompt><command>sbd</command> -d /dev/<replaceable>SBD</replaceable> list</screen>
         <para>このコマンドは、ノードスロットとそれらの現在のメッセージをダンプします。</para>
       </step>
       <step>
         <para>ノードの1つにテストメッセージを送信します。</para>
         <screen><prompt role="root">root # </prompt><command>sbd</command>  -d /dev/<replaceable>SBD</replaceable> message alice test</screen>
         <para/>
         <screen>Sep 22 17:01:00 alice sbd: [13412]: info: Received command test from alice</screen>
       </step>
     </procedure>
   </sect3>

   <sect3 xml:id="pro.ha.storage.protect.sbd.daemon">
    <title>SBDデーモンの起動</title>
    <para>
     SBDデーモンは、クラスタスタックの不可欠なコンポーネントです。このデーモンは、クラスタスタックの実行中はもちろんのこと、クラスタスタックの一部がクラッシュしたときでも、実行されている必要があります。これにより、クラッシュしたノードのフェンシングが可能になります。
    </para>
    <procedure>
     <step>
      <para>
       ブート時のSBDデーモンの起動を有効にするには、次のコマンドを使用します。
      </para>
<screen><prompt role="root">root # </prompt><command>systemctl</command> enable sbd</screen>
     </step>
     <step>
      <para>
       <command>ha-cluster-init</command>を実行します。このスクリプトによりSBDが正しく設定され、設定ファイル<filename>/etc/sysconfig/sbd</filename>が、Csync2で同期される必要のあるファイルのリストに追加されます。
      </para>
      <para>
       SBDを手動で設定する場合は、次の手順を実行します。
      </para>
      <para>
       CorosyncのinitスクリプトでSBDを開始および停止するには、ファイル<filename>/etc/sysconfig/sbd</filename>を編集し、次の行を検索して、<replaceable>SBD</replaceable>をSBDデバイスで置き換えます。
      </para>
<screen>SBD_DEVICE="/dev/<replaceable>SBD</replaceable>"</screen>
      <para>
       1行目で複数のデバイスを指定する必要がある場合は、セミコロンで区切って指定します(デバイスの順序は任意で構いません)。
      </para>
<screen>SBD_DEVICE="/dev/<replaceable>SBD1</replaceable>; /dev/<replaceable>SBD2</replaceable>; /dev/<replaceable>SBD3</replaceable>"</screen>
      <para>
       SBDデバイスがアクセス不能な場合は、SBDデーモンが開始できなくなり、Corosyncの起動を抑止します。
      </para>
      <note>
       <title>ブート時にサービスを開始</title>
       <para>
        SBDデバイスがノードからアクセスできなくなった場合は、ノードが無限の再起動サイクルに入ることあります。これは技術的には正しい振る舞いですが、管理ポリシーによっては、まず間違いなく面倒な問題となるでしょう。そのような場合には、ブート時にCorosyncおよびPacemakerを自動的に開始しないのがよいでしょう。
       </para>
      </note>
     </step>
     <step>
      <para>
       続行する前に、<literal>pacemaker</literal>サービスを停止してから再度開始することで、すべてのノードでSBDが開始していることを確認します。</para>
<screen><prompt role="root">root # </prompt><command>systemctl</command> stop pacemaker
<prompt role="root">root # </prompt><command>systemctl</command> start pacemaker</screen>
      <para>
       これによって、自動的にSBDデーモンの開始がトリガされます。
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="pro.ha.storage.protect.sbd.test">
    <title>SBDのテスト</title>
    <para/>
    <procedure>
     <step>
      <para>
       次のコマンドを使用すると、ノードスロットとそれらの現在のメッセージがSBDデバイスからダンプされます。
      </para>
<screen><prompt role="root">root # </prompt><command>sbd</command> -d /dev/<replaceable>SBD</replaceable> list</screen>
      <para>
       ここに、SBDとともに起動されたすべてのクラスタノードが一覧され、メッセージスロットには<literal>clear</literal>が表示されるはずです。
      </para>
     </step>
     <step>
      <para>
       ノードの1つにテストメッセージを送信してみます。
      </para>
      <screen><prompt role="root">root # </prompt><command>sbd</command> -d /dev/<replaceable>SBD</replaceable> message alice test</screen>
     </step>
     <step>
      <para>
       ノードがシステムログファイルにメッセージの受信を記録します。
      </para>
<screen>Aug 29 14:10:00 alice sbd: [13412]: info: Received command test from bob</screen>
      <para>
       これによって、SBDがノード上で実際に機能し、メッセージを受信できることが確認されます。
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="pro.ha.storage.protect.fencing">
    <title>フェンシングリソースの設定</title>
    <procedure>
     
     <tip>
      <title>2ノードクラスタ用のSTONITH設定</title>
      <para>最新のSPと一緒に2ノードクラスタをインストールした場合、既にこのシナリオに対応した設定となっています。この場合は、このヒントを無視してください。
      </para>
      <para>
       このような2ノードクラスタの設定理由は、タイミングを誤ったフェンシングが頻繁に発生するためです。スプリットブレインシナリオでは、いずれのノードも相手をフェンスしようとします。このダブルフェンシングを避けるには、STONITHリソースの設定に<literal>pcmk_delay_max</literal>パラメータを追加します。これにより、機能しているネットワークカードを備えたサーバが稼動を継続できる可能性が高くなります。</para>
     </tip>
     <step>
      <para>
       SBDのセットアップを完了するには、次のように、SBDをCIB内でSTONITH/フェンシングメカニズムとしてアクティブにします。
      </para>
    
<screen><prompt role="root">root # </prompt><command>crm</command> configure
<prompt role="custom">crm(live)configure# </prompt><command>property</command> stonith-enabled="true"
<prompt role="custom">crm(live)configure# </prompt><command>property</command> stonith-timeout="40s"
<prompt role="custom">crm(live)configure# </prompt><command>primitive</command> stonith_sbd stonith:external/sbd \
  params pcmk_delay_max=30
<prompt role="custom">crm(live)configure# </prompt><command>commit</command>
<prompt role="custom">crm(live)configure# </prompt><command>quit</command></screen>
      <para>
       リソースのクローンを作成する必要はありません。どちらにせよ問題が発生すればそれぞれのノードをシャットダウンすることになるからです。
      </para>
      <para>

       どの値が<literal>stonith-timeout</literal>に設定されているかは、<literal>msgwait</literal>タイムアウトによって異なります。<literal>msgwait</literal>タイムアウトは、基盤のIOシステムで許可されている最大タイムアウトより長い必要があります。たとえば、プレーンなSCSIディスクの場合は、30秒です。<literal>msgwait</literal>タイムアウト値を30秒に設定する場合、<literal>stonith-timeout</literal>を40秒に設定すると適切です。
      </para>

      <para>
       ノードスロットは自動的に割り当てられるので、手動のホストリストを定義する必要はありません。詳細については、<link xlink:href="https://www.suse.com/support/kb/doc.php?id=7016305"/>を参照してください。
      </para>
     </step>
     <step>
      <para>
       以前設定した他のフェンシングデバイスを無効にします。現在、この機能にはSBDメカニズムが使用されるからです。
      </para>
     </step>
    </procedure>
    <para>
     一度リソースが起動すれば、クラスタは共有ストレージフェンシング用に正常に設定されます。クラスタは、ノードのフェンシングが必要になると、この方法を使用します。
    </para>
   </sect3>
   <sect3 xml:id="sec.ha..storageprotection.sgpersist">
    <title>sg_persistリソースの設定</title>
    <para/>
    <remark>toms 2014-09-10: FATE#312345</remark>
    <procedure>
     <step>
      <para>
       <systemitem class="username">root</systemitem>としてログインし、シェルを起動します。
      </para>
     </step>
     <step>
      <para>
       設定ファイル<filename>/etc/sg_persist.conf</filename>を作成します。
      </para>
<screen>sg_persist_resource_MDRAID1() {
      devs="/dev/sdd /dev/sde"
      required_devs_nof=2
}</screen>
     </step>
     <step>
      <para>
       次のコマンドを実行して、プリミティブリソース<literal>sg_persist</literal>を作成します。
      </para>
<screen><prompt role="root">root # </prompt><command>crm</command> configure
<prompt role="custom">crm(live)configure# </prompt><command>primitive</command> sg ocf:heartbeat:sg_persist \
    params config_file=/etc/sg_persist.conf \
           sg_persist_resource=MDRAID1 \
           reservation_type=1 \
    op monitor interval=60 timeout=60</screen>
     </step>
     <step>
      <para>
       <literal>sg_persist</literal>プリミティブをマスタ-スレーブグループに追加します。
      </para>
<screen><prompt role="custom">crm(live)configure# </prompt><command>ms</command> ms-sg sg \
    meta master-max=1 notify=true</screen>
     </step>
     <step>
      <para>
       aliceサーバ上にマスタを設定し、bobノード上にスレーブを設定します。
      </para>
<screen><prompt role="custom">crm(live)configure# </prompt><command>location</command> ms-sg-alice-loc ms-sg inf: alice
<prompt role="custom">crm(live)configure# </prompt><command>location</command> ms-sg-bob-loc ms-sg 100: bob</screen>
     </step>
     <step>
      <para>
       いくつかのテストをします。リソースがマスタ/スレーブステータスの場合は、マスタサーバ上で、<filename>/dev/sdc1</filename>をマウントして、書き込むことができます。ただし、スレーブサーバ上では書き込むことができません。
      </para>
     </step>
    </procedure>
    <para>
     通常、<literal>Filesystem</literal>リソース(たとえば、RAID、LVM、Ext2/3/4/XFSなど)でこのリソースを使用する必要があります。OCFS2およびcLVMでは必要ありません。この場合、次の手順を実行する必要があります。
    </para>
    <procedure>
     <step>
      <para>
       OCFS2プリミティブを追加します。
      </para>
<screen><prompt role="custom">crm(live)configure# </prompt><command>primitive</command> ocfs2 ocf:heartbeat:Filesystem \
    params device="/dev/sdc1" directory="/mnt/ocfs2" fstype=ocfs2</screen>
     </step>
     <step>
      <para>
       <literal>basegroup</literal>からクローンを作成します。
      </para>
<screen><prompt role="custom">crm(live)configure# </prompt><command>clone</command> cl-group basegroup</screen>
     </step>
     <step>
      <para>
       <literal>ms-sg</literal>と<literal>cl-group</literal>の関係を追加します。
      </para>
<screen><prompt role="custom">crm(live)configure# </prompt><command>colocation</command> ocfs2-group-on-ms-sg inf: cl-group ms-sg:Master
<prompt role="custom">crm(live)configure# </prompt><command>order</command> ms-sg-before-ocfs2-group inf: ms-sg:promote cl-group</screen>
     </step>
     <step>
      <para>
       <command>edit</command>コマンドで、すべての変更内容を確認します。
      </para>
     </step>
     <step>
      <para>
       変更をコミットします.
      </para>
     </step>
    </procedure>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.ha.storageprotection.exstoract">
  <title>排他的ストレージアクティベーションの確保</title>

  <para>
   このセクションでは、共有ストレージへのアクセスを1つのノードに排他的にロックする低レベルの追加メカニズムである<literal>sfex</literal>を紹介します。ただし、sfexは、STONITHと置き換えることはできないので注意してください。sfexには共有ストレージが必要なので、上記で説明した<literal>external/sbd</literal>フェンシングメカニズムは、ストレージの別のパーティションで使用することをお勧めします。
  </para>

  <para>
   設計上、sfexは、同時並行性を必要とするOCFS2のようなワークロードには使用できませんが、従来のフェールオーバー方式のワークロードに対しては保護層として機能できます。これは、実際にはSCSI-2予約と似ていますが、もっと一般的です。
  </para>

  <sect2 xml:id="sec.ha.storageprotection.exstoract.description">
   <title>概要</title>
   <para>
    共有ストレージ環境では、ストレージの小さなパーティションが1つ以上のロックの保存用に確保されます。
   </para>
   <para>
    ノードは、保護されたリソースを取得する前に、まず、保護ロックを取得する必要があります。順序は、Pacemakerによって強制され、sfexコンポーネントは、Pacemakerがスプリットブレイン条件に制約されても、ロックが2回以上付与されないことを保証します。
   </para>
   <para>
    ノードのダウンが永続的にロックをブロックせず、他のノードが続行できるように、これらのロックも定期的に更新される必要があります。
   </para>
  </sect2>

  <sect2 xml:id="sec.ha.storageprotection.exstoract.requirements">
   <title>設定</title>
   <para>
    次に、sfexで使用する共有パーティションの作成方法と、CIBでsfexロック用にリソースを設定する方法を説明します。1つのsfexパーティションは任意の数のロックを保持でき、ロックごとに1KBのストレージスペースを割り当てる必要があります。デフォルトでは、sfex_initはパーティション上にロックを1つ作成します。
   </para>
   <important>
    <title>要件</title>
    <itemizedlist>
     <listitem>
      <para>
       sfex用の共有パーティションは、保護するデータと同じ論理ユニットにある必要があります。
      </para>
     </listitem>
     <listitem>
      <para>
       共有されたsfexパーティションは、ホストベースのRAIDやDRBDを使用してはなりません。
      </para>
     </listitem>
     <listitem>
      <para>
       cLVM2論理ボリュームの使用は可能です。
      </para>
     </listitem>
    </itemizedlist>
   </important>
   <procedure>
    <title>sfexパーティションを作成する</title>
    <step>
     <para>
      sfexで使用する共有パーティションを作成します。このパーティションの名前を書き留め、以降の手順の<filename>/dev/sfex</filename>をこの名前で置き換えます。
     </para>
    </step>
    <step>
     <para>
      次のコマンドで、sfexメタデータを作成します。
     </para>
<screen><prompt role="root">root # </prompt><command>sfex_init</command> -n 1 /dev/sfex</screen>
    </step>
    <step>
     <para>
      メタデータが正しく作成されたかどうか検証します。
     </para>
<screen><prompt role="root">root # </prompt><command>sfex_stat</command> -i 1 /dev/sfex ; echo $?</screen>
     <para>
      現在、ロックがかかっていないので、このコマンドは、<literal>2</literal>を返すはずです。
     </para>
    </step>
   </procedure>
   <procedure>
    <title>sfexロック用リソースを設定する</title>
    <step>
     <para>
      sfexロックは、CIB内のリソースを介して表現され、次のように設定されます。
     </para>
<screen><prompt role="custom">crm(live)configure# </prompt><command>primitive</command> sfex_1 ocf:heartbeat:sfex \
#	params device="/dev/sfex" index="1" collision_timeout="1" \
      lock_timeout="70" monitor_interval="10" \
#	op monitor interval="10s" timeout="30s" on-fail="fence"</screen>
    </step>
    <step>
     <para>
      sfexロックによってリソースを保護するには、保護対象とsfexリソース間の必須の順序付けと配置の制約を作成します。保護対象のリソースが<literal>filesystem1</literal>というIDを持つ場合は、次のようになります。
     </para>
<screen><prompt role="custom">crm(live)configure# </prompt><command>order</command> order-sfex-1 inf: sfex_1 filesystem1
<prompt role="custom">crm(live)configure# </prompt><command>colocation</command> colo-sfex-1 inf: filesystem1 sfex_1</screen>
    </step>
    <step>
     <para>
      グループ構文を使用する場合は、sfexリソースを最初のリソースとしてグループに追加します。
     </para>
<screen><prompt role="custom">crm(live)configure# </prompt><command>group</command> LAMP sfex_1 filesystem1 apache ipaddr</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.ha.storage.moreinfo">
  <title>その他の情報</title>

  <itemizedlist>
    <listitem>
      <para><link xlink:href="http://www.linux-ha.org/wiki/SBD_Fencing"/></para>
    </listitem>
    <listitem>
      <para><command>man sbd</command></para>
    </listitem>
  </itemizedlist>
 </sect1>
</chapter>
